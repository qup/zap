/*jslint browser: true, forin: true, plusplus: true, indent: 4 */
(function(
  // Reliable reference to the global object (i.e. window in browsers).
  global,

  // Dummy constructor that we use as the .constructor property for
  // functions that return Generator objects.
  GeneratorFunction,

  // Undefined value, more compressible than void 0.
  undefined
) {
  var hasOwn = Object.prototype.hasOwnProperty;

  if (global.wrapGenerator) {
    return;
  }

  function wrapGenerator(innerFn, outerFn, self, tryList) {
    return new Generator(innerFn, outerFn, self || null, tryList || []);
  }

  global.wrapGenerator = wrapGenerator;
  if (typeof exports !== "undefined") {
    exports.wrapGenerator = wrapGenerator;
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  var Gp = Generator.prototype;
  var GFp = GeneratorFunction.prototype = Object.create(Function.prototype);
  GFp.constructor = GeneratorFunction;
  GFp.prototype = Gp;
  Gp.constructor = GFp;

  wrapGenerator.mark = function(genFun) {
    genFun.__proto__ = GFp;
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Ensure isGeneratorFunction works when Function#name not supported.
  if (GeneratorFunction.name !== "GeneratorFunction") {
    GeneratorFunction.name = "GeneratorFunction";
  }

  wrapGenerator.isGeneratorFunction = function(genFun) {
    var ctor = genFun && genFun.constructor;
    return ctor ? GeneratorFunction.name === ctor.name : false;
  };

  function Generator(innerFn, outerFn, self, tryList) {
    var generator = outerFn ? Object.create(outerFn.prototype) : this;
    var context = new Context(tryList);
    var state = GenStateSuspendedStart;

    function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        throw new Error("Generator has already finished");
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          try {
            var info = delegate.iterator[method](arg);

            // Delegate generator ran and handled its own exceptions so
            // regardless of what the method was, we continue as if it is
            // "next" with an undefined arg.
            method = "next";
            arg = undefined;

          } catch (uncaught) {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = uncaught;

            continue;
          }

          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          if (state === GenStateSuspendedStart &&
              typeof arg !== "undefined") {
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
            throw new TypeError(
              "attempt to send " + JSON.stringify(arg) + " to newborn generator"
            );
          }

          if (state === GenStateSuspendedYield) {
            context.sent = arg;
          } else {
            delete context.sent;
          }

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }
        }

        state = GenStateExecuting;

        try {
          var value = innerFn.call(self, context);

          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: value,
            done: context.done
          };

          if (value === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } catch (thrown) {
          state = GenStateCompleted;

          if (method === "next") {
            context.dispatchException(thrown);
          } else {
            arg = thrown;
          }
        }
      }
    }

    generator.next = invoke.bind(generator, "next");
    generator.throw = invoke.bind(generator, "throw");

    return generator;
  }

  Generator.prototype.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(triple) {
    var entry = { tryLoc: triple[0] };

    if (1 in triple) {
      entry.catchLoc = triple[1];
    }

    if (2 in triple) {
      entry.finallyLoc = triple[2];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry, i) {
    var record = entry.completion || {};
    record.type = i === 0 ? "normal" : "return";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryList.forEach(pushTryEntry, this);
    this.reset();
  }

  wrapGenerator.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    var iterator = iterable;
    var Symbol = global.Symbol;
    if (Symbol && Symbol.iterator in iterable) {
      iterator = iterable[Symbol.iterator]();
    } else if (!isNaN(iterable.length)) {
      var i = -1;
      iterator = function next() {
        while (++i < iterable.length) {
          if (i in iterable) {
            next.value = iterable[i];
            next.done = false;
            return next;
          }
        };
        next.done = true;
        return next;
      };
      iterator.next = iterator;
    }
    return iterator;
  }
  wrapGenerator.values = values;

  Context.prototype = {
    constructor: Context,

    reset: function() {
      this.prev = 0;
      this.next = 0;
      this.sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      // Pre-initialize at least 20 temporary variables to enable hidden
      // class optimizations for simple generators.
      for (var tempIndex = 0, tempName;
           hasOwn.call(this, tempName = "t" + tempIndex) || tempIndex < 20;
           ++tempIndex) {
        this[tempName] = null;
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    _findFinallyEntry: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") && (
              entry.finallyLoc === finallyLoc ||
              this.prev < entry.finallyLoc)) {
          return entry;
        }
      }
    },

    abrupt: function(type, arg) {
      var entry = this._findFinallyEntry();
      var record = entry ? entry.completion : {};

      record.type = type;
      record.arg = arg;

      if (entry) {
        this.next = entry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      var entry = this._findFinallyEntry(finallyLoc);
      return this.complete(entry.completion);
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry, i);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
}).apply(this, Function("return [this, function GeneratorFunction(){}]")());

var $__Object$getPrototypeOf = Object.getPrototypeOf;
var $__Object$create = Object.create;
var $__Object$defineProperty = Object.defineProperty;

(function(Object, mixin) {
    "use strict"; // happy linter ^_____^

    /* <droppable> interesting code after line 110, here
     * ad-hoc polyfill section for this purpose only
     * never use these functions outside this closure ... like ...
ne*/var

        // borrowed methods for unknown Objects
        ObjectPrototype = Object.prototype,

        lookupGetter = ObjectPrototype.__lookupGetter__,
        lookupSetter = ObjectPrototype.__lookupSetter__,
        defineGetter = ObjectPrototype.__defineGetter__,
        defineSetter = ObjectPrototype.__defineSetter__,
        has          = ObjectPrototype.hasOwnProperty,

        emptyArray   = [],
        // slice        = emptyArray.slice,

        // for IE < 9 and non IE5 yet browsers
        goNative = true,
        defineProperty = (function(defineProperty){
          try{
            return defineProperty && defineProperty({},'_',{value:1})._ && defineProperty;
          } catch(IE8) {
            goNative = false;
          }
        }(Object.defineProperty)) ||
        function (o, k, d) {
            var
                get = d.get, // has.call(d, 'get') would be better but
                set = d.set; // ES5 is just like this
            if (get && defineGetter) {
                defineGetter.call(o, k, get);
            }
            if (set && defineSetter) {
                defineSetter.call(o, k, set);
            }
            if (!(get || set)) {
                o[k] = d.value;
            }
        },
        // for IE < 9 and non IE5 yet browsers
        getOwnPropertyNames = (goNative && Object.getOwnPropertyNames) ||
        (function () {
            var
                addHiddenOwnProperties = function (result) {
                    return result;
                },
                list = [],
                key,
                i,
                length;

            for (key in {valueOf: key}) {
                list.push(key);
            }

            if (!list.length) {
                length = list.push(
                    'constructor',
                    'hasOwnProperty',
                    'isPrototypeOf',
                    'propertyIsEnumerable',
                    'toLocaleString',
                    'toString',
                    'valueOf'
                ) - 1;
                addHiddenOwnProperties = function (result, o) {
                    for (i = 0; i < length; i++) {
                        key = list[i];
                        if (has.call(o, key)) {
                            result.push(key);
                        }
                    }
                    return result;
                };
            }

            return function (o) {
                var
                    result = [],
                    key;
                for (key in o) {
                    if (has.call(o, key)) {
                        result.push(key);
                    }
                }
                return addHiddenOwnProperties(result, o);
            };
        }()),
        // IE < 9 or other non ES5 yet browsers
        getOwnPropertyDescriptor = (goNative && Object.getOwnPropertyDescriptor) ||
        function (o, k) {
            var
                descriptor = {
                    enumerable: true,
                    configurable: true
                },
                get = lookupGetter && lookupGetter.call(o, k),
                set = lookupSetter && lookupSetter.call(o, k);
            if (get) {
                descriptor.get = get;
            }
            if (set) {
                descriptor.set = set;
            }
            if (!(get || set)) {
                descriptor.writable = true;
                descriptor.value = o[k];
            }
            return descriptor;
        };
    // </droppable>

    // if already defined get out of here
    // this should be
    // if (mixin in Object) return;
    // but for some reason I went for JSLint ...
    if (Object[mixin]) {
        return;
    }
    // same descriptor as other spec'd methods
    defineProperty(
        Object,
        mixin,
        {
            enumerable: false,
            writable: true,
            configurable: true,
            value: function (
                target, // object to enrich with
                source, // mixin object or Trait (Function)
                args    // optional arguments for Trait
            ) {
                var
                    i,
                    length,
                    keys,
                    key;

                if (typeof source === 'function') {
                    // if the source is a function
                    // it will be invoked with object as target
                    // this let us define mixin as closures
                    // function addFunctionality() {
                    //     this.functionality = function () {
                    //       // do amazing stuff
                    //     }
                    // }
                    // addFunctionality.call(Class.prototype);
                    // addFunctionality.call(genericObject);
                    // // or
                    // Object.mixin(Class.prototype, addFunctionality);

                    source.apply(target, args || emptyArray);
                    /*
                    // try to perform as fast as possible
                    if (arguments.length < 3) {
                        // so if no extra args are passed ...
                        source.call(target);
                    } else {
                        // there is no need to slice them as done here
                        source.apply(target, slice.call(arguments, 2));
                    }
                    */
                } else {
                    // if source is an object
                    // grab all possibe properties
                    // and per each of them ...
                    keys = getOwnPropertyNames(source);
                    length = keys.length;
                    i = 0;
                    while (i < length) {
                        key = keys[i++];
                        // ... define it ...
                        defineProperty(
                            target,
                            key,
                            // ... using the same descriptor
                            getOwnPropertyDescriptor(
                                source,
                                key
                            )
                        );
                    }
                }
                // always return the initial target
                // ignoring all possible different return with functions
                return target;
            }
        }
    );
}(Object, 'mixin'));

var Rectangle = function() {
   function Rectangle(x, y, width, height) {
      this.x = 0 || x;
      this.y = 0 || y;
      this.width = 0 || width;
      this.height = 0 || height;
   }

   return Rectangle;
}();

Rectangle.overlap = function(rectA, rectB) {
   // Calculate half sizes.
   var halfWidthA = rectA.width / 2.0;
   var halfHeightA = rectA.height / 2.0;
   var halfWidthB = rectB.width / 2.0;
   var halfHeightB = rectB.height / 2.0;

   // Calculate centers.
   var centerA = new Vector2(rectA.x + halfWidthA, rectA.y + halfHeightA);
   var centerB = new Vector2(rectB.x + halfWidthB, rectB.y + halfHeightB);

   // Calculate current and minimum-non-intersecting distances between centers.
   var distanceX = centerA.x - centerB.x;
   var distanceY = centerA.y - centerB.y;
   var minDistanceX = halfWidthA + halfWidthB;
   var minDistanceY = halfHeightA + halfHeightB;

   // If we are not intersecting at all, return (0, 0).
   if (Math.abs(distanceX) >= minDistanceX || Math.abs(distanceY) >= minDistanceY) {
      return null;
   }

   // Calculate and return intersection depths.
   var depthX = distanceX > 0 ? minDistanceX - distanceX : -minDistanceX - distanceX;
   var depthY = distanceY > 0 ? minDistanceY - distanceY : -minDistanceY - distanceY;

   return new Vector2(depthX, depthY);
};

var Vector2 = function() {
   function Vector2(x, y) {
      this.x = x || 0;
      this.y = y || 0;
   }

   return Vector2;
}();

Vector2.add = function(a, b, result) {
   result = result || new Vector2();
   result.x = a.x + b.x;
   result.y = a.y + b.y;

   return result;
};

var EventDispatcher = function() {
   function EventDispatcher() {}

   $__Object$defineProperty(EventDispatcher.prototype, "addEventListener", {
      value: function(type, callback) {
         if ( this.eventListeners_ === undefined ) {
            this.eventListeners_ = { };
         }

         var listeners = this.eventListeners_;

         if ( listeners[ type ] === undefined ) {

            listeners[ type ] = [];

         }

         if ( listeners[ type ].indexOf( callback ) === - 1 ) {

            listeners[ type ].push( callback );

         }

      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(EventDispatcher.prototype, "hasEventListener", {
      value: function(type, callback) {

         if ( this.eventListeners_ === undefined ) {
            return false;
         }

         var listeners = this.eventListeners_;

         if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( callback ) !== - 1 ) {

            return true;

         }

         return false;

      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(EventDispatcher.prototype, "removeEventListener", {
      value: function(type, callback) {
         if ( this.eventListeners_ === undefined ) {
            return;
         }

         var listeners = this.eventListeners_;
         var callbacks = listeners[ type ];

         if ( callbacks !== undefined ) {

            var index = callbacks.indexOf( callback );

            if ( index !== - 1 ) {

               callbacks.splice( index, 1 );

            }

         }

      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(EventDispatcher.prototype, "dispatchEvent", {
      value: function(event) {
         if ( this.eventListeners_ === undefined ) {
            return;
         }

         var listeners = this.eventListeners_;
         var callbacks = listeners[ event.type ];

         if ( callbacks !== undefined ) {

            event.target = this;

            var array = [];
            var length = callbacks.length;

            for ( var i = 0; i < length; i ++ ) {
               array[ i ] = callbacks[ i ];
            }

            for ( var i = 0; i < length; i ++ ) {
               array[ i ].call( this, event );
            }
         }
      },

      enumerable: false,
      writable: true
   });

   return EventDispatcher;
}();

var TileSheet = function() {
   function TileSheet() {
      this.image_ = null;
      this.padding_ = 0;
      this.margin_ = 0;
      this.columns_ = 0;
      this.rows_ = 0;
      this.src_ = "";
   }

   $__Object$defineProperty(TileSheet.prototype, "image", {
      get: function() {
         return this.image_;
      },

      set: function(value) {
         this.image_ = value;
      },

      enumerable: false
   });

   $__Object$defineProperty(TileSheet.prototype, "padding", {
      get: function() {
         return this.padding_;
      },

      enumerable: false
   });

   $__Object$defineProperty(TileSheet.prototype, "margin", {
      get: function() {
         return this.margin_;
      },

      enumerable: false
   });

   $__Object$defineProperty(TileSheet.prototype, "columns", {
      get: function() {
         return this.columns_;
      },

      enumerable: false
   });

   $__Object$defineProperty(TileSheet.prototype, "rows", {
      get: function() {
         return this.rows_;
      },

      enumerable: false
   });

   $__Object$defineProperty(TileSheet.prototype, "src", {
      get: function() {
         return this.src_;
      },

      set: function(value) {
         this.src_ = value;
         this.complete_ = false;

         var request = new XMLHttpRequest();
         request.open('GET', value, true);
         request.send();

         var that = this;
         request.addEventListener('load', function (event) {
            var data = JSON.parse(request.responseText);

            that.padding_ = data.padding || 0;
            that.margin_ = data.margin || 0;
            that.columns_ = data.columns || 0;
            that.rows_ = data.rows || 0;

            that.image_ = new Image;
            that.image_.addEventListener('load', function (e) {
               that.complete_ = true;
               that.dispatchEvent(e);
            });

            that.image.src = data.image;
         });
      },

      enumerable: false
   });

   $__Object$defineProperty(TileSheet.prototype, "complete", {
      get: function() {
         return this.complete_;
      },

      enumerable: false
   });

   return TileSheet;
}();

Object.mixin(TileSheet.prototype, EventDispatcher.prototype);

var SpriteSheet = function() {
   function SpriteSheet(image, animations, frames) {
      this.image_ = null;
      this.frames_ = [];
      this.animations_ = { };
      this.frames_ = [];
      this.src_ = "";
   }

   $__Object$defineProperty(SpriteSheet.prototype, "image", {
      get: function() {
         return this.image_;
      },

      set: function(value) {
         this.image_ = value;
      },

      enumerable: false
   });

   $__Object$defineProperty(SpriteSheet.prototype, "src", {
      get: function() {
         return this.src_;
      },

      set: function(value) {
         this.complete_ = false;

         var request = new XMLHttpRequest();
         request.open('GET', value, true);
         request.send();

         var that = this;
         request.addEventListener('load', function (event) {
            var data = JSON.parse(request.responseText);

            // Load the frames.
            var frames = that.frames_;
            for (var i = 0; i < data.frames.length; i++) {
               var frame = new SpriteSheetFrame();

               frame.top = data.frames[i].top;
               frame.left = data.frames[i].left;
               frame.right = data.frames[i].right;
               frame.bottom = data.frames[i].bottom;

               frames[i] = frame;
            }

            var animations = that.animations_;
            for (var key in data.animations) {
               var animation = new SpriteSheetAnimation();
               animation.frames = data.animations[key].frames;
               animations[key] = animation
            }

            var image = new Image;
            image.addEventListener('load', function (e) {
               that.image_ = image;
               that.complete_ = true;
               that.dispatchEvent(e);
            });

            image.src = data.image;
         });

         this.src_ = value;
      },

      enumerable: false
   });

   $__Object$defineProperty(SpriteSheet.prototype, "complete", {
      get: function() {
         return this.complete_;
      },

      enumerable: false
   });

   $__Object$defineProperty(SpriteSheet.prototype, "getFrameByIndex", {
      value: function(index) {
         return this.frames_[index];
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(SpriteSheet.prototype, "getAnimationById", {
      value: function(index) {
         return this.animations_[index];
      },

      enumerable: false,
      writable: true
   });

   return SpriteSheet;
}();

Object.mixin(SpriteSheet.prototype, EventDispatcher.prototype);

var SpriteSheetFrame = function() {
   function SpriteSheetFrame() {}

   $__Object$defineProperty(SpriteSheetFrame.prototype, "costructor", {
      value: function(top, left, right, bottom) {
         this.top = top || 0;
         this.left = left || 0;
         this.right = right || 0;
         this.bottom = bottom || 0;
      },

      enumerable: false,
      writable: true
   });

   return SpriteSheetFrame;
}();

var SpriteSheetAnimation = function() {
   function SpriteSheetAnimation() {
      this.frames = [];
   }

   return SpriteSheetAnimation;
}();

(function() {
   CanvasRenderingContext2D.prototype.drawTile = function(tileSheet, index, x, y, width, height) {
      var tileWidth = tileSheet.image.width / tileSheet.columns;
      var tileHeight = tileSheet.image.height / tileSheet.rows;

      var tileX = Math.floor(index % (tileSheet.image.width / tileWidth)) * tileWidth;
      var tileY = Math.floor(index / (tileSheet.image.width / tileWidth)) * tileHeight;

      // this.drawImage(tileSheet.image, tileX, tileY, tileWidth, tileHeight, x, y, width, height);

      // this.drawImage(tileSheet.image, tileX, tileY, tileWidth, tileHeight, x - (tileWidth / 2), y - (tileHeight / 2), width, height);
      this.drawImage(tileSheet.image, tileX, tileY, tileWidth, tileHeight, x, y, width, height);
   };

   CanvasRenderingContext2D.prototype.drawSprite = function(spriteSheet, index, x, y, color) {
      if (!spriteSheet.complete) {
         return;         
      }
      var spriteBounds = spriteSheet.getFrameByIndex(index);

      var spriteHeight = spriteBounds.bottom - spriteBounds.top;
      var spriteWidth = spriteBounds.right - spriteBounds.left;

      var spriteX = spriteBounds.left;
      var spriteY = spriteBounds.top;

      // this.drawImage(spriteSheet.image, spriteX, spriteY, spriteWidth, spriteHeight, x - (spriteWidth / 2), y - (spriteHeight / 2), spriteWidth, spriteHeight);
      this.drawImage(spriteSheet.image, spriteX, spriteY, spriteWidth, spriteHeight, x, y, spriteWidth, spriteHeight);
   };
})();

// refactor this, but better than having magic values.
var COLLISION_NONE = 0x0000;

var COLLISION_GROUND = 0x0001;
var COLLISION_PLAYER = 0x0002;
var COLLISION_MISSILE = 0x0004;
var COLLISION_ENEMY = 0x0008;

var Cell = function() {
   function Cell(collisionGroup, collisionMask) {
      this.collisionGroup = collisionGroup;
      this.collisionMask = collisionMask || ~0;
   }

   $__Object$defineProperty(Cell.prototype, "impact", {
      value: function(unit) {
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Cell.prototype, "resolve", {
      value: function(unit) {
         var depth = Rectangle.overlap(unit, this);
         if (depth == null) {
            return false;
         }

         if (Math.abs(depth.y) < Math.abs(depth.x)) {
            unit.translate(0, depth.y);
            unit.velocity[1] = 0;
         } else {
            unit.translate(depth.x, 0);
         }

         return true;
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Cell.prototype, "collide", {
      value: function(unit) {
         if (!unit || unit == this) {
            return false;
         }

         // if ((this.collisionGroup & unit.collisionGroup) == 0 && (unit.collisionGroup & this.collisionMask) == 0) {
         //    return false;
         // }

         if (this.index == 0) {
            return false;
         }

         if (!this.resolve(unit)) {
            return false;
         }

         this.impact(unit);
         unit.impact(this);

         return true;
      },

      enumerable: false,
      writable: true
   });

   return Cell;
}();

var Terrain = function() {
   function Terrain(columns, rows, cells, data) {
      this.columns_ = columns;
      this.rows_ = rows;
      this.data_ = data;
      this.cells_ = cells;
   }

   $__Object$defineProperty(Terrain.prototype, "columns", {
      get: function() {
         return this.columns_;
      },

      enumerable: false
   });

   $__Object$defineProperty(Terrain.prototype, "rows", {
      get: function() {
         return this.rows_;
      },

      enumerable: false
   });

   $__Object$defineProperty(Terrain.prototype, "data", {
      get: function() {
         return this.data_;
      },

      enumerable: false
   });

   $__Object$defineProperty(Terrain.prototype, "get", {
      value: function(column, row) {
         return this.data_[row * this.columns + column];
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Terrain.prototype, "collide", {
      value: function(unit, callback) {
         var left = Math.floor(unit.x / 16);
         var right = Math.ceil((unit.x + unit.width) / 16) - 1;
         var top = Math.floor(unit.y / 16);
         var bottom = Math.ceil((unit.y + unit.height) / 16) - 1;

         var result = false;

         for (var y = top; y <= bottom; ++y) {
            for (var x = left; x <= right; ++x) {
               var index = this.get(x, y);

               var cell = this.cells_[index];
               if (cell == undefined) {
                  continue;
               }

               cell.index = index;
               cell.x = x * 16;
               cell.y = y * 16;
               cell.width = 16;
               cell.height = 16;

               if (cell.collide(unit)) {
                   result = true;
               }
            }
         }

         return result;
      },

      enumerable: false,
      writable: true
   });

   return Terrain;
}();

var UnitBehavior = function() {
   function UnitBehavior() {
      this.id = null;
      this.x = 0;
      this.y = 0;
      this.width = 0;
      this.height = 0;
   }

   $__Object$defineProperty(UnitBehavior.prototype, "apply", {
      value: function(unit) {
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(UnitBehavior.prototype, "impact", {
      value: function(unit, object) {
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(UnitBehavior.prototype, "evaluate", {
      value: function(unit, deltaTime) {
      },

      enumerable: false,
      writable: true
   });

   return UnitBehavior;
}();

var SuicideUnitBehavior = function($__super) {
   function SuicideUnitBehavior() {
      $__Object$getPrototypeOf(SuicideUnitBehavior.prototype).constructor.call(this);
   }

   SuicideUnitBehavior.__proto__ = ($__super !== null ? $__super : Function.prototype);
   SuicideUnitBehavior.prototype = $__Object$create(($__super !== null ? $__super.prototype : null));

   $__Object$defineProperty(SuicideUnitBehavior.prototype, "constructor", {
      value: SuicideUnitBehavior
   });

   $__Object$defineProperty(SuicideUnitBehavior.prototype, "impact", {
      value: function(unit, object) {
         if (unit.dead || object.dead) {
            return;
         }

         if (object.kill) {
            object.kill();
         }

         unit.kill();
      },

      enumerable: false,
      writable: true
   });

   return SuicideUnitBehavior;
}(UnitBehavior);

var UnitWanderBehavior = function($__super) {
   function UnitWanderBehavior() {
      this.unit = null;
   }

   UnitWanderBehavior.__proto__ = ($__super !== null ? $__super : Function.prototype);
   UnitWanderBehavior.prototype = $__Object$create(($__super !== null ? $__super.prototype : null));

   $__Object$defineProperty(UnitWanderBehavior.prototype, "constructor", {
      value: UnitWanderBehavior
   });

   $__Object$defineProperty(UnitWanderBehavior.prototype, "collide", {
      value: function(unit, object) {
         //
         //
         if(object.collisionGroup == COLLISION_GROUND && unit.wall) {
            unit.direction = (unit.direction == 'left') ? 'right' : 'left';
         }
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(UnitWanderBehavior.prototype, "evaluate", {
      value: function(unit, deltaTime) {
         unit.move(unit.direction);
      },

      enumerable: false,
      writable: true
   });

   return UnitWanderBehavior;
}(UnitBehavior);

var Unit = function() {
   function Unit() {
      this.type = '';

      this.owner = 0;
      this.level_ = null;

      this.collisionGroup = ~0;
      this.collisionMask = ~0;

      this.behaviors_ = [];

      this.heading_ = [0, 0];
      this.position_ = [0, 0];
      this.previous_ = [0, 0];

      this.velocity_ = [0, 0];
      this.size_ = [0, 0];

      this.dead_ = false;
      this.owner = 0;
      this.passive = false;

      this.width = 10;
      this.height = 10;
      this.mass = 1.0;
      this.direction = 'left';

      this.cooldowns = {
         weapon: 0
      };
   }

   $__Object$defineProperty(Unit.prototype, "level", {
      get: function() {
         return this.level_;
      },

      enumerable: false
   });

   $__Object$defineProperty(Unit.prototype, "gravity", {
      get: function() {
         return this.gravity_ || level.gravity;
      },

      set: function(value) {
         this.gravity_ = value;
      },

      enumerable: false
   });

   $__Object$defineProperty(Unit.prototype, "mover", {
      get: function() {
         return this.mover_;
      },

      enumerable: false
   });

   $__Object$defineProperty(Unit.prototype, "position", {
      get: function() {
         return this.position_;
      },

      enumerable: false
   });

   $__Object$defineProperty(Unit.prototype, "delta", {
      get: function() {
         return [
            this.position_[0] - this.previous_[0],
            this.position_[1] - this.previous_[1]
         ];
      },

      enumerable: false
   });

   $__Object$defineProperty(Unit.prototype, "velocity", {
      get: function() {
         return this.velocity_;
      },

      enumerable: false
   });

   $__Object$defineProperty(Unit.prototype, "heading", {
      get: function() {
         return this.heading_;
      },

      enumerable: false
   });

   $__Object$defineProperty(Unit.prototype, "x", {
      get: function() {
         return this.position[0];
      },

      enumerable: false
   });

   $__Object$defineProperty(Unit.prototype, "y", {
      get: function() {
         return this.position[1];
      },

      enumerable: false
   });

   $__Object$defineProperty(Unit.prototype, "dead", {
      get: function() {
         return this.dead_;
      },

      enumerable: false
   });

   $__Object$defineProperty(Unit.prototype, "kill", {
      value: function() {
         if (this.dead_) {
            return;
         }

         this.dead_ = true;
         this.dispatchEvent({
            type: 'UnitDied',
            unit: this,
         });
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Unit.prototype, "appendBehavior", {
      value: function(behavior) {
         var behaviors = this.behaviors_;
         behaviors.push(behavior);
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Unit.prototype, "impact", {
      value: function(unit) {
         if (this.y < unit.y) {
            this.standing = true;
         }

         if (this.delta[1] != 0) {
            this.velocity[1] = 0;
         } else if (this.delta[0] != 0) {
            this.velocity[0] = 0;
         }

         var behaviors = this.behaviors_;

         for (var i = 0; i < behaviors.length; i++) {
            behaviors[i].impact(this, unit);
         }
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Unit.prototype, "translate", {
      value: function(x, y) {
         this.position[0] = this.position[0] + x;
         this.position[1] = this.position[1] + y;
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Unit.prototype, "resolve", {
      value: function(unit) {
         var depth = Rectangle.overlap(this, unit);
         if (depth == null) {
            return false;
         }

         if (Math.abs(depth.y) < Math.abs(depth.x)) {
            this.translate(0, depth.y);
         } else {
            this.translate(depth.x, 0);
         }

         return true;
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Unit.prototype, "collide", {
      value: function(unit) {
         if (unit == this) {
            return false;
         }

         if ((this.collisionGroup & unit.collisionGroup) == 0 && (unit.collisionGroup & this.collisionMask) == 0) {
            return false;
         }

         if (!this.resolve(unit)) {
            return false;
         }

         this.impact(unit);
         unit.impact(this);

         return true;
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Unit.prototype, "step", {
      value: function(deltaTime) {
         this.previous_[0] = this.position_[0];
         this.previous_[1] = this.position_[1];

         if (this.dead) {
            return;
         }

         for (var key in this.cooldowns) {
            this.cooldowns[key] -= deltaTime;
         }

         var behaviors = this.behaviors_;
         for (var i = 0; i < behaviors.length; i++) {
            behaviors[i].evaluate(this, deltaTime);
         }

         this.velocity[1] = this.velocity[1] + ((980 * this.mass) * deltaTime);

         this.position[0] = this.position[0] + this.velocity[0] * deltaTime;
         this.position[1] = this.position[1] + this.velocity[1] * deltaTime;
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Unit.prototype, "move", {
      value: function(direction) {
         var speed = 50;

         var heading = this.heading[0];

         if (direction == 'left') {
            this.heading[0] = -1;
         } else if (direction == 'right') {
            this.heading[0] = +1;
         }

         // no change needs to occur if the unit is already walking.
         if (this.heading[0] == heading && this.velocity[0] != 0) {
            return;
         }

         this.velocity[0] = this.heading[0] * speed;

         var event = {
            type: 'UnitAbility',
            ability: 'move'
         };

         this.dispatchEvent(event);
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Unit.prototype, "stop", {
      value: function() {
         if (this.velocity[0] == 0) {
            return;
         }

         this.velocity[0] = 0;

         var event = {
            type: 'UnitAbility',
            ability: 'stop'
         };

         this.dispatchEvent(event);
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Unit.prototype, "jump", {
      value: function() {
         if (this.standing) {
            this.velocity[1] = -375;
         }
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Unit.prototype, "shoot", {
      value: function() {
         if (this.cooldowns.weapon > 0) {
            return;
         }

         var speed = 400;
         var missile = new Unit();

         missile.type = 'bullet';
         missile.owner = this.owner;
         missile.mass = 0.0;
         missile.width = 4;
         missile.height = 4;

         missile.position[0] = this.position[0];
         missile.position[1] = this.position[1];
         missile.appendBehavior(new SuicideUnitBehavior());

         missile.collisionGroup = COLLISION_MISSILE;
         missile.collisionMask = COLLISION_GROUND | COLLISION_ENEMY;

         missile.velocity[0] = this.heading[0] * speed;

         this.level.insertUnit(missile);
         this.cooldowns.weapon = 0.25;
      },

      enumerable: false,
      writable: true
   });

   return Unit;
}();

Object.mixin(Unit.prototype, EventDispatcher.prototype);
var stepSize = (1 / 60);

var Level = function() {
   function Level() {
      this.units_ = [];
      this.terrain_ = null;
      this.accumulator = 0;
   }

   $__Object$defineProperty(Level.prototype, "terrain", {
      get: function() {
         return this.terrain_;
      },

      set: function(value) {
         if (this.terrain_ != value) {
            this.terrain_ = value;

            event = {
               type: 'TerrainChanged',
               terrain: this.terrain,
            };

            this.dispatchEvent(event);
         }
      },

      enumerable: false
   });

   $__Object$defineProperty(Level.prototype, "insertUnit", {
      value: function(unit) {
         unit.world_ = this;

         var units = this.units_;
         units.push(unit);
         unit.level_ = this;

         this.dispatchEvent({
            type: 'UnitInserted',
            unit: unit,
         });

         return unit;
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Level.prototype, "removeUnit", {
      value: function(unit) {
         var units = this.units_;
         var index = units.indexOf(unit);
         units.splice(index, 1);

         this.dispatchEvent({
            type: 'UnitRemoved',
            unit: unit,
         });
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Level.prototype, "step", {
      value: function(deltaTime) {
         this.accumulator += deltaTime;

         while(this.accumulator >= stepSize) {
            var terrain = this.terrain_;
            var units = this.units_;

            // Integrate the units.
            for (var i = units.length - 1; i >= 0; i--) {
               var unit = units[i];

               unit.step(stepSize);

               // Since the terrain is static (for now anyhow),
               // it's fine to do those collisions as part of the integration here.
               terrain.collide(unit);
            }

            // Then sort the units by their position.
            units.sort(function(a, b) {
               return (a.y * a.x) - (b.y * b.x);
            });

            for (var i = units.length - 1; i >= 0; i--) {
               var unit = units[i];

               for (var j = units.length - 1; j >= 0; j--) {
                  var other = units[j];

                  // If the unit collides with the other
                  // there is a chance the unit may be penetrating the terrain again.
                  if (unit.collide(other)) {

                     // So we will do another pass at terrain collision,
                     // this might leave the units penetrating each other but thats better than
                     // penetrating the terrain.
                     if (terrain.collide(unit)) {
                        debugger;
                     }
                  }
               }
            }

            this.accumulator -= stepSize;
         }
      },

      enumerable: false,
      writable: true
   });

   return Level;
}();

Object.mixin(Level.prototype, EventDispatcher.prototype);

var Actor = function() {
   function Actor() {
      this.parent_ = null;
      this.children_ = [];
      this.position_ = [];
   }

   $__Object$defineProperty(Actor.prototype, "parent", {
      get: function() {
         return this.parent_
      },

      enumerable: false
   });

   $__Object$defineProperty(Actor.prototype, "stage", {
      get: function() {
         return this.parent ? this.parent.stage : this;
      },

      enumerable: false
   });

   $__Object$defineProperty(Actor.prototype, "x", {
      get: function() {
         return this.position[0];
      },

      enumerable: false
   });

   $__Object$defineProperty(Actor.prototype, "y", {
      get: function() {
         return this.position[1];
      },

      enumerable: false
   });

   $__Object$defineProperty(Actor.prototype, "prependChild", {
      value: function(child) {
         var children = this.children_;

         children.unshift(child);
         child.parent_ = this;
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Actor.prototype, "appendChild", {
      value: function(child) {
         var children = this.children_;

         children.push(child);
         child.parent_ = this;
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Actor.prototype, "removeChild", {
      value: function(child) {
         var children = this.children_;
         var index = children.indexOf(child);
         children.splice(index, 1);
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Actor.prototype, "perform", {
      value: function(deltaTime) {
         var children = this.children_;

         for (var i = 0; i < children.length; i++) {
            children[i].perform(deltaTime);
         }
      },

      enumerable: false,
      writable: true
   });

   return Actor;
}();

var Stage = function($__super) {
   function Stage() {
      $__Object$getPrototypeOf(Stage.prototype).constructor.call(this);

      this.display = null;
   }

   Stage.__proto__ = ($__super !== null ? $__super : Function.prototype);
   Stage.prototype = $__Object$create(($__super !== null ? $__super.prototype : null));

   $__Object$defineProperty(Stage.prototype, "constructor", {
      value: Stage
   });

   return Stage;
}(Actor);

var TileActor = function($__super) {
   function TileActor(tileSheet) {
      $__Object$getPrototypeOf(TileActor.prototype).constructor.call(this);

      this.tileSheet = tileSheet;
      this.data = [];
      this.columns = 0;
      this.rows = 0;
   }

   TileActor.__proto__ = ($__super !== null ? $__super : Function.prototype);
   TileActor.prototype = $__Object$create(($__super !== null ? $__super.prototype : null));

   $__Object$defineProperty(TileActor.prototype, "constructor", {
      value: TileActor
   });

   $__Object$defineProperty(TileActor.prototype, "perform", {
      value: function(deltaTime) {
         if (!this.tileSheet.complete) {
            return;
         }

         var context = this.stage.display.getContext('2d');

         for (var i = 0; i < this.columns; i++) {
            for (var j = 0; j < this.rows; j++) {
               var index = this.data[i + this.columns * j];

               context.drawTile(this.tileSheet, index, i * 16, j * 16, 16, 16);
            }
         }

         context.restore();

         $__Object$getPrototypeOf(TileActor.prototype).perform.call(this);
      },

      enumerable: false,
      writable: true
   });

   return TileActor;
}(Actor);

var SpriteActor = function($__super) {
   function SpriteActor(spriteSheet) {
      $__Object$getPrototypeOf(SpriteActor.prototype).constructor.call(this);

      this.spriteSheet = spriteSheet;
      this.spriteAnimation = null;
      this.spriteAnimationFrame = 0;
      this.spriteAnimationFrameTime = 0;
   }

   SpriteActor.__proto__ = ($__super !== null ? $__super : Function.prototype);
   SpriteActor.prototype = $__Object$create(($__super !== null ? $__super.prototype : null));

   $__Object$defineProperty(SpriteActor.prototype, "constructor", {
      value: SpriteActor
   });

   $__Object$defineProperty(SpriteActor.prototype, "setAnimationById", {
      value: function(id) {
         if (this.spriteAnimation == this.spriteSheet.getAnimationById(id)) {
            return;
         }

         this.spriteAnimation = this.spriteSheet.getAnimationById(id);
         this.spriteAnimationFrame = 0;
         this.spriteAnimationFrameTime = 0;
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(SpriteActor.prototype, "playAnimation", {
      value: function(deltaTime) {
         if (!this.spriteAnimation) {
            return;
         }

         this.spriteAnimationFrameTime += deltaTime;

         if (this.spriteAnimationFrameTime > 0.2) {
            this.spriteAnimationFrame++;
            this.spriteAnimationFrameTime = 0;

            if (this.spriteAnimationFrame == this.spriteAnimation.frames.length) {
               this.spriteAnimationFrame = 0;
            }
         }
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(SpriteActor.prototype, "perform", {
      value: function(deltaTime) {
         if (!this.spriteSheet || !this.spriteAnimation) {
            return;
         }

         this.playAnimation(deltaTime);

         var context = this.stage.display.getContext('2d');
         var spriteFrame = this.spriteAnimation.frames[this.spriteAnimationFrame];
         context.drawSprite(this.spriteSheet, spriteFrame, this.x, this.y);

         $__Object$getPrototypeOf(SpriteActor.prototype).perform.call(this);
      },

      enumerable: false,
      writable: true
   });

   return SpriteActor;
}(Actor);

function createCanvas(window) {
   var canvas = window.document.createElement('canvas');
   canvas.width = window.innerWidth;
   canvas.height = window.innerHeight;
   canvas.oncontextmenu = function(event) {
      event.preventDefault();
   };

   // Disable alpha;
   // canvas.getContext('2d', {alpha: false});

   document.body.appendChild(canvas);
   return canvas;
}

var Game = function() {
   function Game(window) {
      this.window_ = window;
      this.display_ = createCanvas(this.window);
      this.states_ = new Array();

      // Register the required events.
      var events = ['keydown', 'keyup', 'keypress', 'blur', 'focus'];

      for (var event, t$0 = wrapGenerator.values(events), t$1; !(t$1 = t$0.next()).done; ) {
         event = t$1.value;
         this.window.addEventListener(event, this.handleEvent.bind(this));
      }

      this.window.requestAnimationFrame(this.tick.bind(this));
   }

   $__Object$defineProperty(Game.prototype, "window", {
      get: function() {
         return this.window_;
      },

      enumerable: false
   });

   $__Object$defineProperty(Game.prototype, "display", {
      get: function() {
         return this.display_;
      },

      enumerable: false
   });

   $__Object$defineProperty(Game.prototype, "pushState", {
      value: function(state) {
         var states = this.states_;

         // Deactivate the current state, if any.
         if (states.length > 0) {
            states[this.states.length - 1].pause();
         }

         // Push the new state and activate it.
         states.push(state);
         states[states.length - 1].game_ = this;
         states[states.length - 1].activate();
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Game.prototype, "popState", {
      value: function() {
         var states = this.states_;

         if (stack.length > 0) {
            // Deactivate the current state.
            states[states.length - 1].deactivate();
            states[states.length - 1].game_ = null;

            // Then pop it of the stack.
            stack.pop();

            // Activate the preceeding state.
            if (stack.length > 0) {
               stack[stack.length - 1].activate();
            }
         }
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Game.prototype, "changeState", {
      value: function(state) {
         var states = this.states_;

         while(this.currentState) {
            this.popState();
         }

         this.pushState(state);
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Game.prototype, "currentState", {
      get: function() {
         var states = this.states_;

         if (states.length > 0) {
            return states[states.length - 1];
         }

         return null;
      },

      enumerable: false
   });

   $__Object$defineProperty(Game.prototype, "handleEvent", {
      value: function(event) {
         if (this.currentState) {
            this.currentState.handleEvent(event);
         }
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(Game.prototype, "tick", {
      value: function(time) {
         var deltaTime = (time - (this.time || time)) / 1000;
         this.time = time;

         var currentState = this.currentState;

         if (currentState) {
            currentState.step(deltaTime);
            currentState.draw(deltaTime);
         }

         this.window.requestAnimationFrame(this.tick.bind(this));
      },

      enumerable: false,
      writable: true
   });

   return Game;
}();

var GameAction = function() {
   function GameAction(name) {
      var triggers = [].slice.call(arguments, 1);
      this.name = name;
      this.triggers = triggers;
      this.value = 0;
   }

   $__Object$defineProperty(GameAction.prototype, "handleEvent", {
      value: function(event) {
         for (key in this.triggers) {
            var trigger = this.triggers[key];

            trigger.handleEvent(event);

            if (event.defaultPrevented) {
               this.value = trigger.value;
            }
         }
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(GameAction.prototype, "reset", {
      value: function() {
         this.value = 0;
      },

      enumerable: false,
      writable: true
   });

   return GameAction;
}();

var GameTrigger = function() {
   function GameTrigger() {
      this.value = 0;
   }

   $__Object$defineProperty(GameTrigger.prototype, "handleEvent", {
      value: function(event) {
      },

      enumerable: false,
      writable: true
   });

   return GameTrigger;
}();

var GameKeyTrigger = function() {
   function GameKeyTrigger(keyCode) {
      this.keyCode = keyCode;
   }

   $__Object$defineProperty(GameKeyTrigger.prototype, "handleEvent", {
      value: function(event) {
         if (event.keyCode == this.keyCode) {
            if (event.type == 'keydown') {
               this.value = 1;
            } else if (event.type == 'keyup') {
               this.value = 0;
            }

            event.preventDefault();
         }
      },

      enumerable: false,
      writable: true
   });

   return GameKeyTrigger;
}();

var GameState = function() {
   function GameState(game) {
      this.game_ = null;
   }

   $__Object$defineProperty(GameState.prototype, "game", {
      get: function() {
         return this.game_;
      },

      enumerable: false
   });

   $__Object$defineProperty(GameState.prototype, "display", {
      get: function() {
         return this.game.display;
      },

      enumerable: false
   });

   $__Object$defineProperty(GameState.prototype, "handleEvent", {
      value: function(event) {
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(GameState.prototype, "activate", {
      value: function() {
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(GameState.prototype, "deactivate", {
      value: function() {
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(GameState.prototype, "draw", {
      value: function() {
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(GameState.prototype, "update", {
      value: function() {
      },

      enumerable: false,
      writable: true
   });

   return GameState;
}();

var tileSize = 16;

var GamePlayState = function($__super) {
   function GamePlayState() {
      this.actions = {
         'move-left': new GameAction('Move Left', new GameKeyTrigger(37)),
         'move-right': new GameAction('Move Right', new GameKeyTrigger(39)),
         'jump': new GameAction('Move Left', new GameKeyTrigger(38)),
         'shoot': new GameAction('Move Left', new GameKeyTrigger(32)),
      };

      this.level = new Level();

      var stage = new Stage();
      var tileSheet = new TileSheet();
      tileSheet.src = 'tilesheets/tech.json';

      this.level.addEventListener('TerrainChanged', function(event) {
         var actor = new TileActor(tileSheet);

         actor.data = event.terrain.data;
         actor.columns = event.terrain.columns;
         actor.rows = event.terrain.rows;

         stage.prependChild(actor);
      });

      var heroSpriteSheet = new SpriteSheet();
      heroSpriteSheet.src = 'spritesheets/hero.json';

      var enemySpriteSheet = new SpriteSheet();
      enemySpriteSheet.src = 'spritesheets/enemy.json';

      var bulletSpriteSheet = new SpriteSheet();
      bulletSpriteSheet.src = 'spritesheets/bullet.json';

      this.level.addEventListener('UnitInserted', function(event) {
         var unit = event.unit;

         if (unit.type == 'bullet') {
            var spriteSheet = bulletSpriteSheet;
         } else if (unit.type == 'enemy') {
            var spriteSheet = enemySpriteSheet;
         } else {
            var spriteSheet = heroSpriteSheet;
         }

         var actor = new SpriteActor(spriteSheet);
         actor.setAnimationById('idle');
         actor.position = unit.position;

         // XXX making sure the animation gets set.
         heroSpriteSheet.addEventListener('load', function() {
            actor.setAnimationById('idle');
         });

         unit.addEventListener('UnitDied', function() {
            stage.removeChild(actor);
         });

         unit.addEventListener('UnitRemoved', function() {
            stage.removeChild(actor);
         });

         event.unit.addEventListener('UnitAbility', function(ev) {
            if (ev.ability == 'move') {
               actor.setAnimationById('walk');
            } else if (ev.ability == 'stop') {
               actor.setAnimationById('idle');
            }
         });

         stage.appendChild(actor);
      });

      this.stage = stage;

      var data = new Int32Array([
         1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1,
         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
         1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1,
         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
         1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,
         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
         1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,
         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
         1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
         1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1,
      ]);

      var cells = [
         new Cell(COLLISION_NONE, COLLISION_NONE),
         new Cell(COLLISION_GROUND, COLLISION_PLAYER),
      ];

      this.level.terrain = new Terrain(16, 12, cells, data);

      this.playerUnit = new Unit();
      this.playerUnit.position[0] = 40;
      this.playerUnit.position[1] = 30;

      // debugging.
      window.$player = this.playerUnit;

      this.playerUnit.collisionGroup = COLLISION_PLAYER;
      this.playerUnit.collisionMask = COLLISION_GROUND;

      this.level.insertUnit(this.playerUnit);

      this.spawnTime = 0;
   }

   GamePlayState.__proto__ = ($__super !== null ? $__super : Function.prototype);
   GamePlayState.prototype = $__Object$create(($__super !== null ? $__super.prototype : null));

   $__Object$defineProperty(GamePlayState.prototype, "constructor", {
      value: GamePlayState
   });

   $__Object$defineProperty(GamePlayState.prototype, "activate", {
      value: function() {
         this.stage.display = this.display;
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(GamePlayState.prototype, "handleEvent", {
      value: function(event) {
         for (var key in this.actions) {
            var action = this.actions[key];

            action.handleEvent(event);
         }
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(GamePlayState.prototype, "step", {
      value: function(deltaTime) {
         if (this.actions['move-left'].value) {
            this.playerUnit.move('left');
         } else if (this.actions['move-right'].value) {
            this.playerUnit.move('right');
         } else {
            this.playerUnit.stop();
         }

         if (this.actions['jump'].value) {
            this.playerUnit.jump();
            this.actions['jump'].reset();
         }

         if (this.actions['shoot'].value) {
            this.playerUnit.shoot();
         }

         // simplistic respawn
         if (this.playerUnit.dead) {
            this.playerUnit.position[0] = 40;
            this.playerUnit.position[1] = 30;
         }

         // Simplistic spawn.
         this.spawnTime += deltaTime;
         if (this.spawnTime > 1) {
            var unit = new Unit();

            unit.type = 'enemy';
            unit.position[0] = (16 * 16) / 2;
            unit.collisionGroup = COLLISION_ENEMY;
            unit.collisionMask = COLLISION_GROUND | COLLISION_MISSILE;

            this.level.insertUnit(unit);
            unit.appendBehavior(new UnitWanderBehavior());
            this.spawnTime = 0;
         }

         this.level.step(deltaTime);
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(GamePlayState.prototype, "draw", {
      value: function(deltaTime) {
         this.stage.display = this.display;

         var context = this.display.getContext('2d');

         context.setTransform( 1, 0, 0, 1, 0, 0 );
         context.clearRect(0, 0, context.canvas.width, context.canvas.height);

         // var scale = Math.min(context.canvas.width / (this.level.terrain.columns * tileSize), context.canvas.height / (this.level.terrain.rows * tileSize));
         var scale = 3.0;

         context.translate(0.25, 0.25);
         context.scale(scale, scale);


         context.imageSmoothingEnabled = false;
         context.mozImageSmoothingEnabled = false;
         context.webkitImageSmoothingEnabled = false;

         this.stage.perform(deltaTime);
      },

      enumerable: false,
      writable: true
   });

   return GamePlayState;
}(GameState);

var GamePauseState = function() {
   function GamePauseState() {
   }

   $__Object$defineProperty(GamePauseState.prototype, "step", {
      value: function(deltaTime) {
         $__Object$getPrototypeOf(GamePauseState.prototype).step.call(this);
      },

      enumerable: false,
      writable: true
   });

   $__Object$defineProperty(GamePauseState.prototype, "draw", {
      value: function(deltaTime) {
         $__Object$getPrototypeOf(GamePauseState.prototype).draw.call(this);
      },

      enumerable: false,
      writable: true
   });

   return GamePauseState;
}();
